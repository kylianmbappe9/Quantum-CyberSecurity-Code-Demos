# -*- coding: utf-8 -*-
"""Chapter 1: Quantum Phase Kickback

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vN-FF27NPK8c1R7snBj025jfRnYrkX-q

##what is phase kickback
-> phase kickback more of "senses" the information being available at the very moment withuot directly observing the information per se
-> phase kcikback plays a foundation role on many quantum algorithms that plays the "sense the information before interacting" role like Quantum Fourier Transforms, quantum phase estimation, Deuutsch Jotza and Shors algorithm
"""

print("this is the code just to setup our quantum modules and begin our quantum code")
!pip install pennylane
!pip install pylatexenc
!pip install numpy
!pip install matplotlib
!pip install scipy

import pennylane as qml
import numpy as np

num_wires = 5
dev = qml.device("default.qubit", wires=num_wires, shots=1)

"""##  What is Phase Kickback?

Phase kickback is a quantum effect where **phase information from a unitary gate acting on a target register is transferred (or "kicked back") to a control qubit**.

In our case, we use this to build a **quantum lock**. Here's how it works:

- Qubit 0 is the **control** qubit (the ancilla), initialized in a superposition using a Hadamard gate.
- Qubits 1–4 represent the **target register**, where we input a possible key.
- We apply a **controlled unitary**, which flips the phase **only if the target matches a special 4-qubit basis state** — the correct quantum key.

So:
- If the input key matches the secret key, the controlled unitary flips the phase of the state → the control qubit becomes \( |->rangle \).
- If not, the control qubit stays in \( |+>rangle \).

Then a final Hadamard on the control qubit lets us **measure** whether the lock was opened.

"""

def quantum_lock(secret_key):
    return qml.FlipSign(secret_key, wires=[1, 2, 3, 4])


def build_key(key):
    qml.BasisState(np.array(key), wires=[1, 2, 3, 4])

"""little bit easier into our first text, its like lock and key, to unlock a lock, you need a key that matches the pattern of lock. Pressume the quantum lock as the door and build key as your ket, the only way you can unlock a door is when you have a key that matches the door knob to unlock the door"""

@qml.qnode(dev)
def quantum_locking_mechanism(lock, key):
    build_key(key)
    qml.Hadamard(wires=0)
    qml.ctrl(lock, control=0)
    qml.Hadamard(wires=0)
    return qml.sample(wires=0)

def check_key(lock, key):
    result = quantum_locking_mechanism(lock, key)
    if result == 1:
        print("✅ Correct key! Lock opened.")
    else:
        print("❌ Incorrect key.")

secret_key = [1, 1, 0, 1]
lock = quantum_lock(secret_key)

check_key(lock, secret_key)

"""so let's expalin so that everyone understands

1) We have our beginning qubit |0>
2) I set the secret key "it is [0, 1, 1, 1] but I am not going to reveal it unless you try
3) Now you are going to try unlocking this gate BUT it is not me who will have the final laugh but the truth detector [measuring gate] will have the final laugh
4) You tried, guessed and maybe at one point,you guessed it right
5) I wont reveal it yet but my eperession will change (it will be a little bit observable but not too revealing) why? because you are going to ask
6) me and you will go to the truth detector and reveal our unlock code number
6) if its correct, it reveals "it is correct"
else it is worong
"""